var searchIndex = {};
searchIndex['bittorrent'] = {"items":[[0,"","bittorrent","# Rust Bittorrent Library\nThis library is a dependency-free implementation of the bittorrent protocol\nand related extensions. Basic primitives are provided to allow you to connect\nto a tracker and communicate with other peers within a swarm."],[0,"bencode","","Bencode parsing and validation."],[2,"Bencode","bittorrent::bencode","Structure representing bencoded data."],[12,"Int","","Bencode integer.",0],[12,"Bytes","","Bencode bytes which may be convertable to a UTF-8 string.",0],[12,"List","","Bencode list",0],[12,"Dict","","Bencode dictionary",0],[10,"fmt","","",0],[10,"new","","Processes bytes as bencoded data and builds a Bencode structure to represent\nthe bencoded bytes.",0],[10,"encoded","","Serializes the Bencode data structure back into a sequence of bytes.",0],[10,"int","","Tries to convert the current Bencode value to an i64.",0],[10,"bytes","","Tries to convert the current Bencode value to a sequence of bytes.",0],[10,"str","","Tries to convert the current Bencode value to a str (only valid UTF-8\nbyte sequences are convertible).",0],[10,"list","","Tries to convert the current Bencode value to a list of Bencoded values.",0],[10,"dict","","Tries to convert the current Bencode value to a dictionary of Bencoded\nvalues.",0],[0,"error","bittorrent","Error types used by the library."],[1,"ParseError","bittorrent::error","Used when parsing external data that may have errors at any position within\nthe buffer."],[11,"pos","","",1],[11,"desc","","",1],[11,"detail","","",1],[1,"TorrError","","Used to raise an error when a piece of data required by the Torrent is\nmissing from the Bencode data."],[11,"kind","","",2],[11,"desc","","",2],[11,"detail","","",2],[2,"TorrErrorKind","","A list specifying the types of TorrErrors that may occur."],[12,"MissingKey","","A key is missing in one of the bencoded dictionaries.",3],[12,"WrongType","","The data type of one of the bencoded values is wrong.",3],[12,"Other","","An error occurred that is not in this list.",3],[4,"ParseResult","",""],[4,"TorrResult","",""],[10,"fmt","","",1],[10,"new","","Constructs a new ParseError object where the pos information will get\nembedded within the detail value so that it is preserved when accessing\nmethods via Error or when converting to another error.",1],[10,"from_error","","",1],[10,"description","","",1],[10,"detail","","",1],[10,"cause","","",1],[10,"fmt","","",3],[10,"fmt","","",2],[10,"from_error","","",2],[10,"description","","",2],[10,"detail","","",2],[10,"cause","","",2],[0,"peer","bittorrent","Facilitates communication with a remote peer."],[1,"PeerState","bittorrent::peer","Represents the state associated with one side of a peer connection."],[11,"choked","","",4],[11,"interested","","",4],[1,"Peer","","A Peer object representing a connection to a remote peer as well as the\nbittorrent state associated with that connection. Since the messaging\ninterface between a peer is asynchronous, peers will start out as not\nchoked and not interested."],[0,"block","","Unit of data being sent from a remote peer."],[1,"Block","bittorrent::peer::block","Represents a block of data within a piece. Many blocks make up a piece, many\npieces make up a file, and many (or one) file(s) make up the data being pointed\nto by a torrent file."],[10,"with_capacity","","Creates a block with capacity size.",5],[10,"is_active","","Returns true if the current block is marked as active.",5],[10,"set_active","","Marks the current block as active and sets the block information passed in.",5],[10,"set_inactive","","Marks the current block as inactive.",5],[10,"as_mut_slice","","Returns a mutable slice to the data of this block.",5],[10,"piece_index","","Returns the zero based piece index for the piece that this block belongs to.",5],[10,"block_offset","","Returns the byte offset within the piece that this block belongs to.",5],[10,"block_len","","Returns the block length for the current block.",5],[10,"as_slice","","",5],[0,"handshake","bittorrent::peer","Establishing a secure connection with a peer."],[1,"Handshake","bittorrent::peer::handshake","A struct representing a handshake that has successfully taken place."],[10,"initiate","","Initiates a handshake with the recipient sending the designated info hash and peer id.\nIf the response is malformed, the peer sends a different info hash, or the peer sends\nus a peer id that we are already using, the handshake will fail.",6],[10,"complete","","Completes a handshake that was initiated by the remote peer. If the handshake initiated\nby the peer is malformed, the peer sent us a different info hash, or the peer sent us a\npeer id that we are already using, the handshake will fail.",6],[10,"into_peer","","Consumes the handshake object and creates a peer object with the number of\npieces in the current torrent set to num_pieces.",6],[0,"message","bittorrent::peer","Streaming data to and from the remote peer."],[2,"StateChange","bittorrent::peer::message","Represents a state change for one end of a connection."],[12,"Choke","","",7],[12,"Unchoke","","",7],[12,"Interested","","",7],[12,"Uninterested","","",7],[2,"PeerMessage","","Represents a message received from a remote peer."],[12,"Hidden","","Message type has been hidden from client.",8],[12,"StateUpdate","","Peer has changed the state for our end of the connection.",8],[12,"HaveUpdate","","Peer has successfully downloaded a piece.",8],[12,"BitfieldUpdate","","Peer has sent us a list of pieces they currently have.",8],[12,"BlockRequest","","Peer has sent us a request for a block.",8],[12,"CancelRequest","","Peer has sent us a cancel message for a block they requested previously.",8],[12,"BlockReceived","","Peer has sent us a block of data that we requested.",8],[12,"BlockReceivedTooBig","","Peer has sent us a block of data that we requested that is too big to fit\nin the buffer provided by the client.",8],[4,"PieceIndex","",""],[4,"BlockOffset","",""],[4,"BlockLength","",""],[6,"PeerReader","","Trait for reading Peer Wire Protocol messages."],[9,"read_message","","",9],[9,"read_have","","",9],[9,"read_bitfield","","",9],[9,"read_request","","",9],[9,"read_cancel","","",9],[9,"read_block","","",9],[6,"PeerWriter","","Trait for writing Peer Wire Protocol messages."],[9,"write_state","","",10],[9,"write_have","","",10],[9,"write_bitfield","","",10],[9,"write_request","","",10],[9,"write_cancel","","",10],[9,"write_block","","",10],[10,"fmt","","",7],[10,"fmt","","",8],[10,"default","bittorrent::peer","",4],[10,"local_state","","Returns the state associated with our end of the connection.",11],[10,"remote_state","","Returns the state associated with the remote end of the connection.",11],[10,"remote_peer_id","","Returns a reference to a buffer containing the peer id of the remote peer.",11],[10,"process_messages","","Processes all of the messages sent to us from the remote peer.",11],[10,"change_state","","Sends a message to the remote peer telling them that we are changing their state.",11],[10,"notify_have","","Sends a message to the remote peer telling them that we have successfully\ndownloaded and verified the hash of piece.",11],[10,"notify_bitfield","","Sends a message to the remote peer telling them that the bits set in each byte\ncorrespond to the pieces we have downloaded.",11],[10,"request_block","","Sends a message to the remote peer telling them that we are requesting a specific\nblock of a specific length of a designated piece.",11],[10,"cancel_block","","Sends a message to the remote peer telling them that we are cancelling a prior\nrequest for a block.",11],[10,"send_block","","Sends a message to the remote peer telling them that we are sending a block\nof data to them.",11],[0,"torrent","bittorrent","Torrent parsing and validation via the Bencode object."],[1,"Torrent","bittorrent::torrent","A type representing a valid torrent file."],[1,"TorrFile","","Used to represent a file within a torrent file."],[2,"TorrFileType","","Used to represent the type of torrent file."],[12,"Single","","",12],[12,"Multi","","",12],[10,"new","","Goes through the Bencode object and pulls out the fields required by a\nvalid torrent file. Any extraneous fields that may be present within\nthe Bencode object are ignored and will not be considered an error.",13],[10,"announce","","Returns the url of the main tracker for the current torrent file.",13],[10,"announce_list","","Optionally returns a list of urls pointing to backup trackers for the\ncurrent torrent file.",13],[10,"comment","","Optionally returns any comment within the current torrent file.",13],[10,"created_by","","Optionally returns the created by tag within the current torrent file.",13],[10,"creation_date","","Optionally returns the creation date of the current torrent file in\nstandard UNIX epoch format.",13],[10,"file_type","","Returns a tuple of the type of torrent file as well as the associated name.\nSee below for what the second tuple value represents:",13],[10,"files","","Returns a list of file objects for the current torrent.",13],[10,"piece_length","","Returns the piece length for each file.",13],[10,"pieces","","Returns the pieces byte array for the current torrent.",13],[10,"fmt","","",12],[10,"length","","Returns the total number of bytes in the current file.",14],[10,"file_sum","","Optionally returns the md5sum of the current file.",14],[10,"path","","Optionally returns a list of str values that correspond to directories\nexcept for the last value which is the filename for the current file.",14],[0,"tracker","bittorrent","Unified interface for communicating with different trackers."],[1,"ScrapeInfo","bittorrent::tracker","Statistics for a specific torrent."],[11,"leechers","","",15],[11,"seeders","","",15],[11,"downloads","","",15],[1,"AnnounceInfo","","Information pertaining to the swarm we are in."],[11,"interval","","",16],[11,"leechers","","",16],[11,"seeders","","",16],[11,"peers","","",16],[0,"udp","","Facilitates interaction with a UDP Tracker."],[1,"UdpTracker","bittorrent::tracker::udp",""],[10,"new","","Creates a new UdpTracker object.",17],[10,"local_ip","","",17],[10,"scrape","","",17],[10,"start_announce","","",17],[10,"update_announce","","",17],[10,"stop_announce","","",17],[10,"complete_announce","","",17],[6,"Tracker","bittorrent::tracker","Interface for communicating with an generic tracker."],[9,"local_ip","","Returns the local ip address that is being used to communicate with the tracker.",18],[9,"scrape","","Returns information about the swarm for a particular torrent file without\njoining the swarm.",18],[9,"start_announce","","Sends an announce request to the tracker signalling a start event. This request\nenters us into the swarm and we are required to send periodic updates as \nspecified by the tracker in order to be kept in the swarm. Periodic updates \nshould be sent with update_announce.",18],[9,"update_announce","","Sends an announce request to the tracker signalling an update event. This request\nacts as a heartbeat so that the tracker knows we are still connected and wanting\nto be kept in the swarm.",18],[9,"stop_announce","","Sends an announce request to the tracker signalling a stop event. This request\nexists to let the tracker know that we are gracefully shutting down and that\nit should remove us from the swarm.",18],[9,"complete_announce","","Sends an announce request to the tracker signalling a completed event. This request\nexists to let the tracker know that we have completed our download TEST TO CHECK\nWHAT EXACTLY THIS MAKES THE TRACKER DO.",18],[0,"types","bittorrent",""],[1,"PeerID","bittorrent::types","Represents a Peer ID which is a UTF-8 sequence of PEER_ID_LEN characters."],[1,"InfoHash","","Represents an Info Hash which is a byte sequence of length INFO_HASH_LEN;"],[18,"PEER_ID_LEN","",""],[18,"INFO_HASH_LEN","",""],[10,"from_str","","Creates a PeerID struct.",19],[10,"as_slice","","",19],[10,"from_bytes","","Creates an InfoHash struct.",20],[10,"as_slice","","",20],[0,"upnp","bittorrent",""],[1,"ServiceDesc","bittorrent::upnp","Type used to represent a service description. Service actions can be viewed\nas well as related in and out parameters and service state variables."],[2,"UPnPIntf","","Type used to represent different interfaces available on a network as defined\nby the UPnP specification. This type can be used to get very general information\nabout an interface but also to get access to the services exposed by the interface."],[4,"StrPos","","A tuple consisting of start and end position."],[10,"actions","","Returns a list of string slices corresponding to each action that can be\nsent to this service. The slice includes the action name, and any in or out\nparameters expected/provided as well as their related state variables. The \n\"relatedStateVariable\" corresponds to an entry in the \"serviceStateTable\".",21],[10,"state_variables","","Optionally returns a string slice corresponding to the \"serviceStateTable\"\nof the service description. This table explains the data types referenced\nin the \"relatedStateVariable\" field for each in or out parameters for each\naction.",21],[10,"send_action","","Takes an action string representing the procedure to call as well as an\narray slice of tuples in the form (arg_name, arg_value). An empty array \nslice indicates that no parameters are expected for the specified action.",21],[10,"find_all","","Sends out a search request for all UPnP interfaces on the specified from_addr.",22],[10,"find_services","","Sends out a search request for particular UPnP services on the specified from_addr.",22],[10,"find_devices","","Sends out a search request for particular UPnP devices on the specified from_addr.",22],[10,"find_uuid","","Sends out a search request for a unique UPnP interface on the specified from_addr.",22],[10,"is_root","","Check if the current UPnPIntf represents a root device on the network.",22],[10,"is_device","","Check if the current UPnPIntf represents a device on the network.",22],[10,"is_service","","Check if the current UPnPIntf represents a service on the network.",22],[10,"is_identifier","","Check if the current UPnPIntf represents an identifier (uuid) on the network.",22],[10,"name","","Get the device name, service specification, or uuid that this interface\nhas identified itself with.",22],[10,"version","","Get the device version, service version, or no version (in the case of an\nidentifier or root) that this interface has identified itself with.",22],[10,"location","","Get the location (url) of the root device description web page corresponding\nto this particular UPnPIntf.",22],[10,"st","","Get the search target of this UPnPIntf.",22],[10,"usn","","Get the full Unique Service Name of this UPnPIntf.",22],[10,"service_desc","","Get a service description object for this service.",22],[0,"util","bittorrent","Utilities used throughout the library."],[2,"Choice","bittorrent::util",""],[12,"One","","",23],[12,"Two","","",23],[2,"Transport","",""],[12,"TCP","","",24],[12,"UDP","","",24],[12,"HTTP","","",24],[3,"get_net_addrs","","Returns a list of all local IPv4 Addresses."],[3,"get_udp_sock","","Attempts to open a udp connection on addr.\n \nIf the connection is unsuccessful, it will try again up to (attempts - 1)\ntimes, incrementing the port for each attempt."],[3,"get_udp_wait","","The standard wait algorithm defined in the UDP Tracker Protocol. Returned value\nis in seconds."],[3,"gen_peer_id","","Generates a peer id from a base identifier followed by random characters."],[3,"get_transport","","Takes a url and returns the transport type that it specifies."],[3,"get_sockaddr","","Returns the first found DNS entry as a SocketAddr for the specified url."],[3,"get_path","","Returns the path portion of a supplied url."],[3,"get_error","","Used to fill an IoError with a kind and desc, leaving detail empty."]],"paths":[[2,"Bencode"],[1,"ParseError"],[1,"TorrError"],[2,"TorrErrorKind"],[1,"PeerState"],[1,"Block"],[1,"Handshake"],[2,"StateChange"],[2,"PeerMessage"],[6,"PeerReader"],[6,"PeerWriter"],[1,"Peer"],[2,"TorrFileType"],[1,"Torrent"],[1,"TorrFile"],[1,"ScrapeInfo"],[1,"AnnounceInfo"],[1,"UdpTracker"],[6,"Tracker"],[1,"PeerID"],[1,"InfoHash"],[1,"ServiceDesc"],[2,"UPnPIntf"],[2,"Choice"],[2,"Transport"]]};
initSearch(searchIndex);
